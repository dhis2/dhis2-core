package org.hisp.dhis.analytics.util.optimizer.cte.pipeline;

import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.select.PlainSelect;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.select.SelectVisitorAdapter;
import net.sf.jsqlparser.statement.select.SubSelect;
import net.sf.jsqlparser.statement.select.WithItem;
import net.sf.jsqlparser.util.deparser.ExpressionDeParser;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * This class is responsible for identifying qualifying CTEs that are
 * generated by a Program Indicator expression.  A CTE qualifies if:
 * 1. Its name starts with "pi_" (case-insensitive).
 * 2. It contains a correlated subquery within its WHERE clause.  The correlation
 *   is checked by looking for references to the 'subax' alias within the subquery.
 */
public class CteSubqueryIdentifier implements SqlOptimizationStep {
    private final static String CTE_IDENTIFIER = "pi_";
    private static final String CORRELATION_ALIAS = "subax";

    /**
     * Finds and returns a list of WithItem objects (CTEs) that qualify for CTE optimization.
     * A CTE qualifies if:
     * 1. Its name starts with "pi_" (case-insensitive).
     * 2. It contains a correlated subquery within its WHERE clause.  The correlation
     *    is checked by looking for references to the 'subax' alias within the subquery.
     *
     * @param statement The parsed SQL statement (must be a Select statement).
     * @return A list of qualifying WithItem objects.  Returns an empty list if no
     *         qualifying CTEs are found, or if the input is not a Select statement.
     */
    public List<WithItem> findQualifyingPiCtes(Statement statement) {
        List<WithItem> qualifyingWithItems = new ArrayList<>();

        if (statement instanceof Select select) {
            List<WithItem> withItems = select.getWithItemsList();

            if (withItems != null) {
                for (WithItem withItem : withItems) {
                    if (isQualifyingPiCte(withItem)) {
                        qualifyingWithItems.add(withItem);
                    }
                }
            }
        }

        return qualifyingWithItems;
    }

    /**
     * Checks if a given WithItem (CTE) qualifies for optimization.
     * A CTE qualifies if its name starts with "pi_" (case-insensitive) and
     * it contains a correlated subquery in its WHERE clause.
     *
     * @param withItem The WithItem (CTE) to check.
     * @return True if the WithItem qualifies, false otherwise.
     */
    private boolean isQualifyingPiCte(WithItem withItem) {
        return withItem.getName().toLowerCase().startsWith(CTE_IDENTIFIER) &&
                hasCorrelatedSubqueryInWhereClause(withItem);
    }

    /**
     * Checks if a given WithItem (CTE) contains a correlated subquery
     * within its WHERE clause.
     *
     * @param withItem The WithItem (CTE) to check.
     * @return True if a correlated subquery is found in the WHERE clause,
     *         false otherwise.
     */
    private boolean hasCorrelatedSubqueryInWhereClause(WithItem withItem) {
        AtomicBoolean hasSubquery = new AtomicBoolean(false);

        withItem.getSubSelect().getSelectBody().accept(new SelectVisitorAdapter() {
            @Override
            public void visit(PlainSelect plainSelect) {
                if (plainSelect.getWhere() != null) {
                    plainSelect.getWhere().accept(new ExpressionDeParser() {
                        @Override
                        public void visit(SubSelect subSelect) {
                            if (isCorrelatedSubquery(subSelect)) {
                                hasSubquery.set(true);
                            }
                        }
                    });
                }
            }
        });
        return hasSubquery.get();
    }

    /**
     * Checks if a given SubSelect is a correlated subquery that uses
     * the expected correlation alias ("subax").
     *
     * @param subSelect The SubSelect to check.
     * @return True if the SubSelect is correlated and uses "subax",
     *         false otherwise.
     */
    private boolean isCorrelatedSubquery(SubSelect subSelect) {
        AtomicBoolean isCorrelated = new AtomicBoolean(false);

        subSelect.getSelectBody().accept(new SelectVisitorAdapter() {
            @Override
            public void visit(PlainSelect plainSelect) {
                if (plainSelect.getWhere() != null) {
                    plainSelect.getWhere().accept(new ExpressionDeParser() {
                        @Override
                        public void visit(Column column) {
                            if (column.getTable() != null && column.getTable().getName() != null) {
                                if (CORRELATION_ALIAS.equalsIgnoreCase(column.getTable().getName())) {
                                    isCorrelated.set(true);
                                }
                            }
                        }
                    });
                }
            }
        });
        return  isCorrelated.get(); // Only need to check for correlation
    }
}
